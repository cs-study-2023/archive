# CPU Scheduling

CPU 이용률을 극대화하기 위해서는 멀티프로그래밍(multiprogramming)이 필요하다. 하지만 만약 CPU core가 하나라면 한 번에 하나의 프로세스만 실행 가능할 것이다. 이때 필요한 것이 CPU 스케줄링이다.

즉, CPU 스케줄링은 언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업이라고 할 수 있다.

## CPU - I/O 버스트 사이클 (CPU - I/O Burst Cycle)

프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성된다.

프로세스의 실행은 CPU Burst로 시작된다. 뒤이어 I/O Burst가 발생하고, 그 뒤를 이어 또 다른 CPU Burst가 발생하며, 이어 또 다른 I/O Burst 등등으로 진행된다. 결국 아래의 그림처럼 마지막 CPU Burst는 실행을 종료하기 위한 시스템 요청과 함께 끝난다.

- Burst: '한 작업을 연속적으로 처리하는 것'으로, 보통 작업 처리에 필요한 시간을 의미

![annotation](img/CPU_scheduling1.png)

## CPU Scheduler

CPU가 유휴 상태가 될 때마다, 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행해야 한다. 선택 절차는 CPU 스케줄러(CPU Scheduler)에 의해 수행된다.

CPU 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.

![annotation](img/CPU-scheduling2.png)

**\*준비 큐:** CPU 할당을 기다리는 큐  
**\*대기 큐:** I/O를 기다리는 큐

CPU 스케줄링의 결정은 다음의 네 가지 상황에서 발생할 수 있다.

1. 한 프로세스가 **실행 상태 -> 대기 상태**로 전환될 때 (I/O 발생)
2. 프로세스가 **실행 상태 -> 준비 완료 상태**로 전환될 때 (인터럽트 발생)
3. 프로세스가 **대기 상태 -> 준비 완료 상태**로 전환될 때 (I/O 종료)
4. **프로세스가 종료**할 때

### 비선점 스케줄링(nonpreemptive)

일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지, 또는 대기 상태로 전환해 **CPU를 방출할 때까지 점유한다.** (1, 4번)

### 선점 스케줄링(preemptive)

시분할 시스템에서 타임 슬라이스가 소진되었거나, 인터럽트나 시스템 호출 종료시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때, **현 실행 프로세스로부터 강제로 CPU를 회수하는 것이다.** (2, 3번)

### 디스패처 (Dispatcher)

디스패처(Dispatcher)는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈이다.  
한 프로세스에서 다른 프로세스로 문맥을 교환하는 일을 한다.

## CPU 스케줄링 평가 기준

### 1. CPU 이용률(CPU utilization)  

시간당 CPU를 사용한 시간의 비율.

프로세서를 실행상태로 항상 유지하려고 해야 한다.

### 2. 처리율(Throughput)

시간당 처리한 작업의 비율.

단위 시간당 완료되는 작업 수가 많도록 해야 한다.

### 3. 반환시간(Turnaround Time)

프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간

작업이 준비 큐(ready queue)에서 기다린 시간부터 CPU에서 실행된 시간, I/O 작업 시간의 합이다.

### 4. 대기시간(Waiting Time)

대기열에 들어와 CPU를 할당받기 까지 기다린 시간

준비 큐에서 기다린 시간의 총합

### 5. 반응시간(Response Time)

대기열에서 처음으로 CPU를 얻을 때까지 걸린 시간

대기시간과 비슷하지만 다른 점은, 대기시간은 준비 큐에서 기다린 모든 시간을 합친 것이지만 반응 시간은 CPU를 할당받은 최초의 순간까지 기다린 시간 한번 만을 측정한다.

    CPU 이용률과 처리율은 극대화하는 것이 좋고 반환시간, 대기시간, 반응시간은 줄이는 것이 일반적으로 좋다. 그러나 대부분은 trade-off가 있으므로 상황에 맞게 선택하면 된다.

## CPU 스케줄링 알고리즘

### 1. 선입 선처리 스케줄링 (First Come First Served Scheduling, FCFS)

---

FCFS(First Come First Served) 스케줄링은 ready 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식이다. 다른 말로 FIFO(first in first out)라고도 한다.

즉, 프로세스가 ready queue에 도착한 순서대로 실행되며 비선점형 방식이기 때문에 한 번 실행되면 그 프로세스가 끝나야만 다음 프로세스를 실행할 수 있다.

![annotation](img/CPU-scheduling3.png)

다음과 같이 ready 큐는 head, tail이 있는 linked list 형태로 만들어져 있고, head에서 실행할 프로세스를 하나씩 빼낸다. 또한 tail에는 앞으로 실행할 프로세스들을 차곡차곡 쌓아둔다.

이렇게 실행 상태로 간 프로세스는 CPU 자원을 할당받고, 프로세스가 완료될 때까지 CPU를 놓지않는다.**(비선점)**

#### 문제점

FCFS 스케줄링 알고리즘은 단순하고 공평하지만, 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어지는 문제가 있다. 이를 **convoy effect 또는 호위 효과**라고 한다.

### 2. 최단 작업 우선 스케줄링 (Shortest Job First Schduling)

---

ready queue에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 방식이다.

SJF 스케줄링 알고리즘은 주어진 프로세스 집합에 대해 **최소의 평균 대기 시간**을 가진다. 즉, 효율성이 높다.

또한 SJF 알고리즘은 **선점형이거나 또는 비선점형**일 수 있다. 비선점형일 경우 앞의 프로세스가 실행되는 동안 새로운 프로세스가 준비 큐에 도착하면 선택이 발생한다.

#### 문제점

SJF스케줄링은 다음과 같은 이유로 사용하기 힘들다.

- 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.
- 실행 시간이 긴 프로세스의 순서기 계속 밀려 CPU를 할당받지 못하는 starvation 현상이 일어날 수 있다.

### 3. 라운드 로빈 스케줄링 (Round Robin Scheduling RR)

---

![annotation](img/CPU-scheduling4.png)

#### 선입 선처리 스케줄링 + 타임 슬라이스(time slice)

큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 이용 가능한 선점형 스케줄링이다.  
정해진 시간을 모두 사용했지만 아직 프로세스가 완료되지 않았다면 큐의 맨 뒤에 삽입(문맥교환)한다.

할당 시간 내에 처리를 완료하지 못하면 다음 프로세스로 넘어가므로 **선점형 방식**이다.

타임 슬라이스 크기가 중요하다.

- 타임 슬라이스 크기가 너무 크면 호위 효과가 생길 수 있다.
- 타임 슬라이스 크기가 너무 작으면 문맥 교환 시 오버헤드가 발생 할 수 있다.

### 4. 우선순위 스케줄링 (Priority Scheduling)

---

프로세스들에 우선순위를 부여하고 우선순위가 높은 프로세스부터 실행한다.  
우선순위가 같은 프로세스들이 있다면 선입 선처리로 스케줄링한다.

![annotation](img/CPU-scheduling5.png)

    최단 작업 우선 스케줄링(SJF), 최소 잔여 시간 우선 스케줄링 ⊂ 우선순위 스케줄링

모든 우선순위 스케줄링은 낮은 우선순위 프로세스들이 무한히 대기하는 기아(starvation) 현상이 발생할 수 있다.

이를 해결할 대표적인 방법으론 **에이징(aging)** 이 있다.  
오랫동안 대기한 프로세스의 우선순위를 점차 증가시키는 방법이다. 우선 순위가 낮아도 시간이 지나면 언젠가는 우선순위가 높아질 수 있다.

### 5. 다단계 큐 스케줄링 (Multilevel Queue Scheduling)

---

우선순위 스케줄링의 발전된 형태로 우선순위별 준비 큐(A, B, C)를 여러 개 사용하는 스케줄링 방식이다.

![annotation](img/CPU-scheduling6.png)

- 우선순위가 가장 높은 큐(A)에 있는 프로세스들 먼저 쭉 처리
- 우선 순위가 가장 높은 큐가 비어있으면 그다음 우선순위 큐(B)에 있는 프로세스들을 처리한다.

위 그림과 같이 프로세스 유형에 따라 프로세스를 여러 개의 개별 큐로 분할하기 위해 사용할 수도 있다.

**큐 별로 스케줄링을 달리 적용해서 프로세스를 유형별로 처리할 수 있다.**

#### 문제점

큐 간의 이동이 불가해서 기아 현상이 발생할 수 있다.

### 6. 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)

---

다단계 큐 스케줄링 단점을 보완한 방식으로 큐 간의 이동이 가능한 스케줄링 방식이다.

![annotation](img/CPU-scheduling7.png)

우선순위대로 처리를 하면서 만약 할당된 시간 내 끝내지 못한 프로세스가 있다면, 다음으로 높은 우선순위 큐에 삽입해서 처리한다. (preempted)  
이렇게 하면 CPU를 많이 사용해야 하는 프로세스의 우선순위가 낮아지게 된다.

    -> CPU 집중 프로세스의 우선순위는 상대적으로 낮아지고, 입출력 집중 프로세스의 우선순위는 상대적으로 높아진다.

### 7. HRN (Highest Response-ratio Next) 스케줄링

---

SJF에서 발생할 수 있는 starvation 현상을 해결하기 위해 만들어진 비선점형 알고리즘이다. **최고 응답률 우선 스케줄링**이라고도 한다.
![annotation](img/CPU-scheduling9.png)

![annotation](img/CPU-scheduling8.png)

SJF 스케줄링은 프로세스의 실행 시간이 판단 기준이다.  
반면 HRN 스케줄링은 서비스를 받기 위해 **기다린 시간(대기 시간)과 CPU 사용 시간**을 고려하여 스케줄링을 하는 방식이다.

SJF 스케줄링과 비교하면 대기 시간이 긴 프로세스의 우선순위를 높임으로서 CPU를 할당받을 확률을 높인다. 그러나 여전히 공평성이 위배되어 많이 사용되지 않는다.

## 예상 질문

- CPU 스케줄링이란 무엇인가요?
- CPU 스케줄링의 성능 척도에는 어떤 것들이 있나요?
- CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요? (몇개만 골라서 설명)

## 참고 링크

https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html  
https://code-lab1.tistory.com/45  
https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-5%ED%8E%B8-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%812-%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98FCFS-SJF-HRN
https://github.com/devSquad-study/2023-CS-Study/blob/main/OS/os_cpu_scheduling_and_algorithm.md  
https://lealea.tistory.com/242
