**클래스로더란?**

클래스로더는 자바 프로그램이 실행되는 동안 클래스를 동적으로 로드하고 링크하는 역할을 수행하는 JVM의 핵심 구성 요소이다. 클래스 로더는 로딩, 링크, 초기화 세 가지 단계로 나뉘어져 있다.

1. **로딩 (Loading):**
    - 자바 클래스 파일(.class)을 읽어와 메소드 영역에 저장한다.
    - 각 클래스 파일은 해당 클래스와 그의 부모 클래스의 정보, 클래스 파일의 유형 (Class, Interface, Enum), 그리고 변수와 메소드 등의 정보를 메소드 영역에 저장한다.
2. **링크 (Linking):**
    - **검증 (Verification):** 로드된 클래스가 자바 언어 및 JVM 명세에 맞게 잘 구성되어 있는지 검사한다.
    - **준비 (Preparation):** 클래스가 필요로 하는 메모리를 할당하고, 필드와 메소드, 인터페이스 등을 나타내는 데이터 구조를 준비한다.
    - **분석 (Resolution):** 심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체한다.
3. **초기화 (Initialization):**
    - 클래스 변수들을 적절한 값으로 초기화한다..
    - static 필드들은 설정된 값으로 초기화되어야 한다.

자바의 동적 로딩(Dynamic Loading) 특성을 지원하여 프로그램 실행 중에 필요한 클래스들을 동적으로 로드하고 초기화한다. 이는 자바의 유연성과 확장성을 높여주며, 필요한 클래스들만 메모리에 올라가기 때문에 효율적인 자원 관리를 가능하게 한다.

**클래스 로더의 종류:**

1. **부트스트랩 클래스 로더 (Bootstrap Class Loader):**
    - JVM 시작 시 최초에 실행되는 클래스 로더로, 자바 클래스를 로드하는 것이 아니라 자바 클래스를 로드할 수 있는 자바 자체의 클래스 로더와 최소한의 자바 클래스(**`java.lang.Object`**, **`Class`**, **`ClassLoader`**)만을 로드한다.
    - Java 8에서는 **`jre/lib/rt.jar`**와 같은 JDK의 내부 클래스를 로드했지만, Java 9 이후에는 **`/lib`** 내에 모듈화되어 포함되었고, 정확하게 **`ClassLoader`** 내 최상위 클래스들만을 로드한다.
2. **확장 클래스 로더 (Extension Class Loader):**
    - 부트스트랩 클래스 로더를 부모로 갖는 클래스 로더로서, 확장 자바 클래스들을 로드한다.
    - Java 8에서는 **`URLClassLoader`**를 상속하며, **`jre/lib/ext`** 내의 모든 클래스를 로드했지만
        
        Java 9 이후에는 Platform Loader로 변경되었고, **`BuiltinClassLoader`**를 상속하며, Inner Static 클래스로 구현되어 있다.
        
3. **시스템 클래스 로더 (System Class Loader):**
    - 자바 프로그램 실행 시 지정한 Classpath에 있는 클래스 파일이나 JAR 파일에 속한 클래스들을 로드하는 클래스 로더이다.
    - 사용자가 만든 **`.class`** 확장자 파일을 로드하며, 자바 애플리케이션에서 가장 일반적으로 사용되는 클래스 로더 중 하나입니다.

**클래스로더 동작 방식**

1. **메소드 영역 확인:**
    - JVM의 메소드 영역에 해당 클래스가 이미 로드되어 있는지 확인합니다. 만약 로드되어 있다면 해당 클래스를 사용합니다.
2. **시스템 클래스 로더에 로드 요청:**
    - 메소드 영역에 클래스가 로드되어 있지 않을 경우, 시스템 클래스 로더에게 클래스 로드를 요청합니다.
3. **확장 클래스 로더로 요청 위임:**
    - 시스템 클래스 로더는 확장 클래스 로더에게 클래스 로드를 위임합니다.
4. **부트스트랩 클래스 로더로 요청 위임:**
    - 확장 클래스 로더는 부트스트랩 클래스 로더에게 클래스 로드를 위임합니다.
5. **부트스트랩 Classpath 확인:**
    - 부트스트랩 클래스 로더는 부트스트랩 Classpath (주로 JDK/JRE/LIB 디렉토리)에 해당 클래스가 있는지 확인합니다.
    - 클래스가 존재하지 않는 경우, 요청을 확장 클래스 로더에게 넘깁니다.
6. **확장 Classpath 확인:**
    - 확장 클래스 로더는 확장 Classpath (주로 JDK/JRE/LIB/EXT 디렉토리)에 해당 클래스가 있는지 확인합니다.
    - 클래스가 존재하지 않는 경우, 요청을 시스템 클래스 로더에게 넘깁니다.
7. **시스템 Classpath 확인:**
    - 시스템 클래스 로더는 시스템 Classpath에 해당 클래스가 있는지 확인합니다.
    - 클래스가 존재하지 않는 경우, ClassNotFoundException을 발생시킵니다.
    

**클래스 로더의 세 가지 원칙:**

1. **위임 원칙 (Delegation Principle):**
    - 클래스 로더는 클래스나 리소스를 찾을 때 요청을 받으면 이를 상위 클래스 로더에게 위임하는 원칙을 따른다.
    - 클래스 로더는 요청된 클래스를 먼저 자신이 찾아보고, 없으면 상위 클래스 로더에게 위임하여 계층적으로 클래스를 찾아나가게 된다.
    - 위임 원칙을 통해 클래스 로더 간의 계층 구조가 형성되며, 최상위 클래스 로더에서는 시스템 클래스 로더, 확장 클래스 로더 등을 포함하는 구조를 가진다.
2. **가시 범위 원칙 (Visibility Principle):**
    - 하위 클래스 로더는 상위 클래스 로더가 로드한 클래스를 볼 수 있지만, 상위 클래스 로더는 하위 클래스 로더가 로드한 클래스를 알 수 없는 원칙이다.
    - 이로써 클래스 간의 가시성이 유지되면서도 각 클래스 로더 간에 독립성이 유지된다.
    - 가시 범위 원칙은 상위 클래스 로더에서 로드한 클래스가 하위 클래스 로더에서 사용 가능하게 하여 클래스 간의 협력이 가능하도록 한다.
3. **유일성의 원칙 (Uniqueness Principle):**
    - 하위 클래스 로더가 상위 클래스 로더에게 이미 로드된 클래스를 다시 로드하지 않아야 하는 원칙이다.
    - 위임 원칙에 따라 요청된 클래스를 먼저 로드한 클래스 로더가 해당 클래스를 제공하는데, 동일한 클래스를 중복으로 로드하지 않도록 한다.
    - 유일성의 원칙은 메모리 낭비를 방지하고 클래스의 일관성을 유지하며, 클래스의 신뢰성을 보장한다.


**예상 질문**

1. 클래스 로더란?
2. 클래스 로더의 동작 방식을 간단하게 말해주세요.
3. 클래스 로더의 세가지 원칙을 말해주세요.